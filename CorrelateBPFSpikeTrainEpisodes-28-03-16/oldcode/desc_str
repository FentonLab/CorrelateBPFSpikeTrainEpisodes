ReadBPFHeader.c:	dp = sess->data;
ReadBPFHeader.c:	BPFRecordTypes = sess->BPFRecordTypes;
ReadBPFHeader.c:		(void) sprintf(sess->date_str, "(dd/mm/yyyy) %s", Parameters[0]);
ReadBPFHeader.c:		(void) sprintf(sess->time_str, "(hh:mm) %s", Parameters[0]);
ReadBPFHeader.c:	sess->BPFRecordSizes[EEG_BPF_REC_TYPE] = EEG_BPF_REC_SIZE;
ReadBPFHeader.c:	sess->BPFRecordSizes[SINGLE_BPF_REC_TYPE] = SINGLE_BPF_REC_SIZE;
ReadBPFHeader.c:	sess->BPFRecordSizes[STEREO_BPF_REC_TYPE] = STEREO_BPF_REC_SIZE;
ReadBPFHeader.c:	sess->BPFRecordSizes[TETRODE_BPF_REC_TYPE] = TETRODE_BPF_REC_SIZE;
ReadBPFHeader.c:	sess->BPFRecordSizes[SYNC_BPF_REC_TYPE] = SYNC_BPF_REC_SIZE;
ReadBPFHeader.c:	sess->BPFRecordSizes[POSITION_BPF_REC_TYPE] = POSITION_BPF_REC_SIZE;
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[EEG_BPF_REC_TYPE]){
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[SINGLE_BPF_REC_TYPE]){
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[STEREO_BPF_REC_TYPE]){
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[TETRODE_BPF_REC_TYPE]){
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[SYNC_BPF_REC_TYPE]){
ReadBPFHeader.c:	if(sess->BPFRecordTypeNumbers[POSITION_BPF_REC_TYPE]){
ReadBPFHeader.c:	sess->bpf_data = HeaderEnd;
ReadBPFHeader.c:	RecordTypes = sess->BPFRecordTypes;
ReadBPFHeader.c:	RecordSizes = sess->BPFRecordSizes;
ReadBPFHeader.c:		sess->BPFRecordTypeNumbers[i] = 0;
ReadBPFHeader.c:		sess->BPFEEGChannels = NULL;
ReadBPFHeader.c:			sess->BPFEEGChannels = (ui4 *)calloc(NumberOfParameters, sizeof(ui4));
ReadBPFHeader.c:                		sscanf(Parameters[i],"%d", &(sess->BPFEEGChannels[i]));
ReadBPFHeader.c:                sscanf(Parameters[0],"%d", &(sess->BPFRecordTypeNumbers[RecType]));
allocate_memory.c:	x_size = sess->params->x_size;
allocate_memory.c:	y_size = sess->params->y_size;
allocate_memory.c:	area = sess->params->area;
allocate_memory.c:	n_units = sess->num_cells + sess->num_probes;
allocate_memory.c:	sess->cells = (CELL **) gmem((size_t) n_units, sizeof(CELL *));
allocate_memory.c:	sess->cells[0] = (CELL *) gmem((size_t) n_units, sizeof(CELL));
allocate_memory.c:		sess->cells[i] = sess->cells[0] + i;
allocate_memory.c:	sess->probes = sess->cells + sess->num_cells;
allocate_memory.c:		cp = sess->cells[i];
allocate_memory.c:		if (sess->directives->make_rate_maps) {
allocate_memory.c:		if (sess->directives->make_show_rate_maps) {
allocate_memory.c:		if (sess->directives->make_smoothed_rate_maps) {
allocate_memory.c:			if (sess->opts->smoothed_rate_maps) {
allocate_memory.c:	tp = sess->time = (TIME *) gmem((size_t) 1, sizeof(TIME));
allocate_memory.c:	if (sess->directives->make_time_map) {
allocate_memory.c:		if (sess->opts->time_map) {
allocate_memory.c:	ap = sess->apparatus = (APPARATUS *) gmem((size_t) 1, sizeof(APPARATUS));
allocate_memory.c:	if (sess->directives->calc_speed) {
allocate_memory.c:		sp = sess->speed = (SPEED *) gmem((size_t) 1, sizeof(SPEED));
allocate_memory.c:		if (sess->directives->make_speed_map) {
allocate_memory.c:			if (sess->opts->speed_map) {
calculate_direction.c:	n_recs = sess->num_recs;
calculate_direction.c:	rec = sess->recs;
calculate_direction.c:	min_dist = sess->params->min_inter_led_dist;
calculate_direction.c:	max_dist = sess->params->max_inter_led_dist;
calculate_mean_waveforms.c:	n_recs = sess->num_recs;
calculate_mean_waveforms.c:	recs = sess->recs;
calculate_mean_waveforms.c:	cm = sess->cell_map;
calculate_mean_waveforms.c:	n_cells = sess->num_cells;
calculate_mean_waveforms.c:		cp = sess->cells[i];	
calculate_speed.c:	speed_samp_interval = (si4) (((sf8) sess->params->position_samp_freq * (sf8) SPEED_TIME_INTERVAL) + 0.5);
calculate_speed.c:	n_recs = sess->num_recs;
calculate_speed.c:	recs = sess->recs;
calculate_speed.c:	max_dt = (sf8) speed_samp_interval * (((sf8) TIME_STAMPS_PER_SECOND / (sf8) sess->params->position_samp_freq) * (1.0 + MAX_TIME_STAMP_ERROR));
clean_spike_maps.c:        area = sess->params->area;
clean_spike_maps.c:	n_units = sess->num_cells + sess->num_probes;
clean_spike_maps.c:	am = sess->apparatus->map[0];
clean_spike_maps.c:		cp = sess->cells[i];
clean_time_map.c:        area = sess->params->area;
clean_time_map.c:	tp = sess->time;
clean_time_map.c:	am = sess->apparatus->map[0];
clean_time_map.c:	thresh = (sf4) sess->time->threshold;
coher.c:	if(sess->opts->no_pos_samp)	/* no point in calculating coherence */
coher.c:	area = sess->params->area;
coher.c:	x_size = sess->params->x_size;
coher.c:	y_size = sess->params->y_size;
coher.c:	time = sess->time->map;
coher.c:	n_units = sess->num_cells + sess->num_probes;
coher.c:		cp = sess->cells[i];
collapse_pixels.c:	rec = sess->recs;
collapse_pixels.c:	n_recs = sess->num_recs;
collapse_pixels.c:	pcf = sess->params->pixel_collapse_factor;
collapse_pixels.c:		pcf = sess->params->pixel_collapse_factor = PIXEL_COLLAPSE_FACTOR_DFLT;
extract_eeg.c:	(void) sprintf(eeg_file, "%s%s", get_env_var("EEG_DIR"), sess->name_str);
extract_eeg.c:	n_recs = sess->num_recs;
extract_eeg.c:	recs = sess->recs;
extract_eeg.c:	(void) sprintf(eeg_file, "%s\%s", get_env_var("EEG_DIR"), sess->name_str);
extract_eeg.c:	n_recs = sess->num_recs;
extract_eeg.c:	recs = sess->recs;
extract_eeg.c:		(void)fprintf(ofp,"UFF File: %s, probe %d\nEEG_Sampling_frequency\t%0.0lf\nPOSITION_Sampling\t%0.0lf\n", sess->name_str, probe, eeg_data.samp_freq, sess->params->position_samp_freq);
fill_app_holes.c:        x_size = sess->params->x_size;
fill_app_holes.c:        y_size = sess->params->y_size;
fill_app_holes.c:        area = sess->params->area;
fill_app_holes.c:	app = sess->apparatus;
fill_theta_fields.c:	n_recs = sess->num_recs;
fill_theta_fields.c:	recs = sess->recs;
fill_xy_fields.c:	n_recs = sess->num_recs;
fill_xy_fields.c:	recs = sess->recs;
fill_xy_fields.c:	if (sess->opts->no_pos_samp){
filter_recs_for_events.c:	n_recs = sess->num_recs;
filter_recs_for_events.c:	recs = sess->recs;
filter_recs_for_events.c:	bf = sess->params->event_begin_flag;
filter_recs_for_events.c:	ef = sess->params->event_end_flag;
filter_recs_for_events.c:	sess->num_recs = j;
filter_recs_for_events.c:	sess->recs = (RECORD *) realloc((void *) recs, (size_t) j * sizeof(RECORD));
filter_recs_for_non_theta.c:	n_recs = sess->num_recs;
filter_recs_for_non_theta.c:	recs = sess->recs;
filter_recs_for_non_theta.c:	sess->num_recs = i;
filter_recs_for_non_theta.c:	sess->recs = (RECORD *) realloc((void *) recs, (size_t) i * sizeof(RECORD));
filter_recs_for_stillness.c:	n_recs = sess->num_recs;
filter_recs_for_stillness.c:	recs = sess->recs;
filter_recs_for_stillness.c:	max_still_speed = sess->params->max_still_speed;
filter_recs_for_stillness.c:	sess->num_recs = i;
filter_recs_for_stillness.c:	sess->recs = (RECORD *) realloc((void *) recs, (size_t) i * sizeof(RECORD));
filter_recs_for_theta.c:	n_recs = sess->num_recs;
filter_recs_for_theta.c:	recs = sess->recs;
filter_recs_for_theta.c:	sess->num_recs = i;
filter_recs_for_theta.c:	sess->recs = (RECORD *) realloc((void *) recs, (size_t) i * sizeof(RECORD));
filter_recs_for_walking.c:	n_recs = sess->num_recs;
filter_recs_for_walking.c:	recs = sess->recs;
filter_recs_for_walking.c:	min_walking_speed = sess->params->min_walking_speed;
filter_recs_for_walking.c:	sess->num_recs = i;
filter_recs_for_walking.c:	sess->recs = (RECORD *) realloc((void *) recs, (size_t) i * sizeof(RECORD));
get_app_map.c:        x_size = sess->params->x_size;
get_app_map.c:        y_size = sess->params->y_size;
get_app_map.c:        area = sess->params->area;
get_app_map.c:	tm = sess->time->map;
get_app_map.c:	app = sess->apparatus;
get_app_map.c:	if (sess->opts->read_app_map) {
get_app_map.c:	if (sess->opts->fill_app_holes)
get_app_map.c:	if (sess->opts->write_app_map)
get_cell_data.c:	area = sess->params->area;
get_cell_data.c:	time = sess->time->map[0];
get_cell_data.c:	total_secs = sess->time->total_secs;
get_cell_data.c:	n_units = sess->num_cells + sess->num_probes;
get_cell_data.c:		cp = sess->cells[i];
get_cell_data.c:		if(sess->opts->no_pos_samp == FALSE){
get_cell_data.c:	if(sess->opts->no_pos_samp == FALSE)
get_data.c:	if (sess->opts->km_file){
get_data.c:	}else if (sess->opts->ts_file){
get_data.c:	}else if (sess->opts->bpf_file){
get_data.c:	(void) sprintf(sess_path, "%s/%s", data_dir, sess->name_str); 
get_data.c:	sess->file_len = (ui4) stat_struct.st_size;
get_data.c:	sess->data = (ui1 *) gmem((size_t) sess->file_len, sizeof(ui1));
get_data.c:	n_read = (ui4) fread((void *) sess->data, sizeof(ui1), (size_t) sess->file_len, fp);
get_data.c:	if (n_read != sess->file_len) {
get_date_time.c:		(void) fprintf(stderr, "%cBad weekday string in file %s.\n", 7, sess->name_str);
get_date_time.c:		(void) fprintf(stderr, "%cBad month string in file %s.\n", 7, sess->name_str);
get_date_time.c:	(void) sprintf(sess->date_str, "%s, %s %d, %s", day_of_week, month, day_of_month, year);
get_date_time.c:	(void) sprintf(sess->time_str, "%d:%s %s", hour, minute, meridian);
get_eeg.c:	n_recs = sess->num_recs;
get_eeg.c:	recs = sess->recs;
get_eeg.c:		(void) fprintf(stderr, "%c\n\tNo eeg probes in file \"%s\". Terminating program.\n\n", 7, sess->name_str);
get_eeg.c:				(void) fprintf(stderr, "%c\n\tMore than one eeg probe in file \"%s\". Terminating program.\n\n", 7, sess->name_str);
get_eeg.c:	n_recs = sess->num_recs;
get_eeg.c:	recs = sess->recs;
get_eeg.c:		(void) fprintf(stderr, "%c\n\tNo eeg probes in file \"%s\". Terminating program.\n\n", 7, sess->name_str);
get_eeg.c:				(void) fprintf(stderr, "%c\n\tMore than one eeg probe in file \"%s\". Terminating program.\n\n", 7, sess->name_str);
get_field_data.c:	n_units = sess->num_cells + sess->num_probes;
get_field_data.c:		cp = sess->cells[i];
get_field_data.c:	cp = sess->cells[cell_num];
get_field_data.c:	time = sess->time->map;
get_field_data.c:	x_size = sess->params->x_size;
get_field_data.c:	y_size = sess->params->y_size;
get_field_data.c:	cp = sess->cells[cell_num];
get_field_data.c:	time = sess->time->map[0];
get_field_data.c:	area = sess->params->area;
get_pos_samp_freq.c:	recs = sess->recs;
get_pos_samp_freq.c:	n_recs = sess->num_recs;
get_pos_samp_freq.c:	if (sess->opts->no_pos_samp) {
get_pos_samp_freq.c:		sess->params->position_samp_freq = (sf4) TIME_STAMPS_PER_SECOND;
get_pos_samp_freq.c:	if (sess->opts->ts_file) {
get_pos_samp_freq.c:		// sess->params->position_samp_freq was set in get_recs_from_ts()
get_pos_samp_freq.c:	sess->params->position_samp_freq = (sf4) ((si4) (((sf8) TIME_STAMPS_PER_SECOND / mean) + 0.5));
get_pos_samp_freq.c:	mean = (sf8) TIME_STAMPS_PER_SECOND / (sf8) sess->params->position_samp_freq;
get_records.c:	dp = sess->data;
get_records.c:		(void) fprintf(stderr, "%cerror reading header of %s\n", 7, sess->name_str); 
get_records.c:	current_byte = dp - sess->data;
get_records.c:	file_len = sess->file_len;
get_records.c:			(void) fprintf(stderr, "%cunknown record type in file %s -> file may be damaged\n", 7, sess->name_str); 
get_records.c:		(void) fprintf(stderr, "%cfile %s appears truncated, ignoring last record\n", 7, sess->name_str);
get_records.c:	sess->num_recs = total_recs;
get_records.c:	sess->recs = (RECORD *) gmem((size_t) total_recs, sizeof(RECORD)); 
get_records.c:	rp = sess->recs;
get_records.c:	(void) qsort((void *) sess->recs, (size_t) total_recs, sizeof(RECORD), rec_time_sort); 
get_recs_from_bpf.c:	dp = sess->bpf_data;
get_recs_from_bpf.c:	rec_sizes = sess->BPFRecordSizes;
get_recs_from_bpf.c:	current_byte = sess->bpf_data - sess->data;
get_recs_from_bpf.c:	file_len = sess->file_len;
get_recs_from_bpf.c:			(void) fprintf(stderr, "%cunknown record type in file %s -> file may be damaged\n", 7, sess->name_str); 
get_recs_from_bpf.c:		(void) fprintf(stderr, "%cfile %s appears truncated, ignoring last record\n", 7, sess->name_str);
get_recs_from_bpf.c:	sess->num_recs = total_recs;
get_recs_from_bpf.c:	sess->recs = (RECORD *) gmem((size_t) total_recs, sizeof(RECORD)); 
get_recs_from_bpf.c:	first_eeg_channel = sess->BPFEEGChannels[0]; // BPF has a list of eeg channels in the header but not in the EEG records
get_recs_from_bpf.c:	rp = sess->recs;
get_recs_from_bpf.c:	(void) qsort((void *) sess->recs, (size_t) total_recs, sizeof(RECORD), rec_time_sort); 
get_recs_from_km.c:	strcpy(sess->date_str, "not available");
get_recs_from_km.c:	strcpy(sess->time_str, "not available");
get_recs_from_km.c:	strcpy(sess->desc_str, "not available");
get_recs_from_km.c:	file_len = sess->file_len;
get_recs_from_km.c:	data = sess->data;
get_recs_from_km.c:	rp = sess->recs = (RECORD *) gmem((size_t) total_recs, sizeof(RECORD));
get_recs_from_km.c:	sess->num_recs = total_recs;
get_recs_from_ts.c:	strcpy(sess->date_str, "not available");
get_recs_from_ts.c:	strcpy(sess->time_str, "not available");
get_recs_from_ts.c:	strcpy(sess->desc_str, "not available");
get_recs_from_ts.c:        file_len = sess->file_len;
get_recs_from_ts.c:	data = sess->data;
get_recs_from_ts.c:	sess->params->position_samp_freq = pos_samp_interval;
get_recs_from_ts.c:		sess->params->pixel_collapse_factor = scale_y;
get_recs_from_ts.c:	rp = sess->recs = (RECORD *) gmem((size_t) total_recs, sizeof(RECORD));
get_recs_from_ts.c:	sess->num_recs = total_recs;
make_cell_map.c:	sess->cell_map = (si1 **) gmem((size_t) MAX_PROBES, sizeof(si1 *));
make_cell_map.c:	sess->cell_map[0] = (si1 *) gmem((size_t) max_clusts, sizeof(si1));
make_cell_map.c:		sess->cell_map[i] = sess->cell_map[0] + j;
make_cell_map.c:	cm = sess->cell_map;
make_cell_map.c:	n_recs = sess->num_recs;
make_cell_map.c:	recs = sess->recs;
make_cell_map.c:	if (sess->opts->elim_clusts)
make_cell_map.c:	else if (sess->opts->keep_clusts)
make_cell_map.c:	else if (!sess->opts->anal_zero_clusts)
make_cell_map.c:	sess->num_cells = 0;
make_cell_map.c:			cma[i] = sess->num_cells++;
make_cell_map.c:	if (sess->num_cells == 0) {
make_cell_map.c:	sess->num_probes = 0;
make_cell_map.c:	sess->probe_map = (si1 *) gmem((size_t) MAX_PROBES, sizeof(si1));
make_cell_map.c:	(void) memset((void *) sess->probe_map, NOT_CUT, (size_t) MAX_PROBES);
make_cell_map.c:	if (sess->opts->anal_probes) {
make_cell_map.c:				sess->probe_map[i] = sess->num_probes++;
make_directional_subdivisions.c:	n_dir_bins = sess->params->map_dir_bins;
make_directional_subdivisions.c:	n_units = sess->num_cells + sess->num_probes;
make_directional_subdivisions.c:	sess->directional_subdivisions = (SESSION **) gmem((size_t) n_dir_bins, sizeof(SESSION *));
make_directional_subdivisions.c:		sess->directional_subdivisions[i] = (SESSION *) gmem((size_t) 1, sizeof(SESSION));
make_directional_subdivisions.c:		*(sess->directional_subdivisions[i]) = *sess;
make_directional_subdivisions.c:		dvsn = sess->directional_subdivisions[i];
make_directional_subdivisions.c:		dvsn->time->threshold = sess->time->threshold;
make_directional_subdivisions.c:			dvsn->cells[j]->rate_thresh = sess->cells[j]->rate_thresh;
make_directional_subdivisions.c:		dvsn->apparatus->map = sess->apparatus->map;
make_directional_subdivisions.c:	n_bins = sess->params->map_dir_bins;
make_directional_subdivisions.c:	n_recs = sess->num_recs;
make_directional_subdivisions.c:	recs = sess->recs;
make_directional_subdivisions.c:		new_recs[i] = sess->directional_subdivisions[i]->recs = (RECORD *) gmem((size_t) n_new_recs[i], sizeof(RECORD));
make_directional_subdivisions.c:		sess->directional_subdivisions[i]->num_recs = n_new_recs[i];
make_directional_subdivisions.c:	*opts = *sess->opts;
make_directional_subdivisions.c:	*dvsn->params = *sess->params;
make_directional_subdivisions.c:	dvsn->params->read_bkpts_file = sess->params->write_bkpts_file;
make_field_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_field_maps.c:	x_size = sess->params->x_size;
make_field_maps.c:	y_size = sess->params->y_size;
make_field_maps.c:	area = sess->params->area;
make_field_maps.c:		cp = sess->cells[i];
make_field_maps.c:	x_size = sess->params->x_size - 1;
make_field_maps.c:	y_size = sess->params->y_size - 1;
make_field_maps.c:	area = sess->params->area;
make_field_maps.c:	cp = sess->cells[cell_num];
make_field_maps.c:	area = sess->params->area;
make_field_maps.c:	cp = sess->cells[cell_num];
make_phase_subdivisions.c:	n_phase_bins = sess->params->map_phase_bins;
make_phase_subdivisions.c:	n_units = sess->num_cells + sess->num_probes;
make_phase_subdivisions.c:	sess->phase_subdivisions = (SESSION **) gmem((size_t) n_phase_bins, sizeof(SESSION *));
make_phase_subdivisions.c:		sess->phase_subdivisions[i] = (SESSION *) gmem((size_t) 1, sizeof(SESSION));
make_phase_subdivisions.c:		*(sess->phase_subdivisions[i]) = *sess;
make_phase_subdivisions.c:		dvsn = sess->phase_subdivisions[i];
make_phase_subdivisions.c:		dvsn->time->threshold = sess->time->threshold;
make_phase_subdivisions.c:			dvsn->cells[j]->rate_thresh = sess->cells[j]->rate_thresh;
make_phase_subdivisions.c:		dvsn->apparatus->map = sess->apparatus->map;
make_phase_subdivisions.c:	n_bins = sess->params->map_phase_bins;
make_phase_subdivisions.c:	n_recs = sess->num_recs;
make_phase_subdivisions.c:	recs = sess->recs;
make_phase_subdivisions.c:		new_recs[i] = sess->phase_subdivisions[i]->recs = (RECORD *) gmem((size_t) n_new_recs[i], sizeof(RECORD));
make_phase_subdivisions.c:		sess->phase_subdivisions[i]->num_recs = n_new_recs[i];
make_phase_subdivisions.c:	*opts = *sess->opts;
make_phase_subdivisions.c:	*dvsn->params = *sess->params;
make_phase_subdivisions.c:	dvsn->params->read_bkpts_file = sess->params->write_bkpts_file;
make_rate_maps.c:        area = sess->params->area;
make_rate_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_rate_maps.c:	tm = sess->time->map[0];
make_rate_maps.c:		cp = sess->cells[i];
make_rotational_dir_subdivisions.c:	n_units = sess->num_cells + sess->num_probes;
make_rotational_dir_subdivisions.c:	sess->rotational_dir_subdivisions = (SESSION **) gmem((size_t) n_rot_dirs, sizeof(SESSION *));
make_rotational_dir_subdivisions.c:		sess->rotational_dir_subdivisions[i] = (SESSION *) gmem((size_t) 1, sizeof(SESSION));
make_rotational_dir_subdivisions.c:		*(sess->rotational_dir_subdivisions[i]) = *sess;
make_rotational_dir_subdivisions.c:		dvsn = sess->rotational_dir_subdivisions[i];
make_rotational_dir_subdivisions.c:		dvsn->time->threshold = sess->time->threshold;
make_rotational_dir_subdivisions.c:			dvsn->cells[j]->rate_thresh = sess->cells[j]->rate_thresh;
make_rotational_dir_subdivisions.c:		dvsn->apparatus->map = sess->apparatus->map;
make_rotational_dir_subdivisions.c:	n_recs = sess->num_recs;
make_rotational_dir_subdivisions.c:	recs = sess->recs;
make_rotational_dir_subdivisions.c:	cent_x = (sf8) sess->apparatus->center_x;
make_rotational_dir_subdivisions.c:	cent_y = (sf8) sess->apparatus->center_y;
make_rotational_dir_subdivisions.c:		new_recs[i] = sess->rotational_dir_subdivisions[i]->recs = (RECORD *) gmem((size_t) n_new_recs[i], sizeof(RECORD));
make_rotational_dir_subdivisions.c:		sess->rotational_dir_subdivisions[i]->num_recs = n_new_recs[i];
make_rotational_dir_subdivisions.c:	*opts = *sess->opts;
make_rotational_dir_subdivisions.c:	*dvsn->params = *sess->params;
make_rotational_dir_subdivisions.c:	dvsn->params->read_bkpts_file = sess->params->write_bkpts_file;
make_show_field_maps.c:        x_size = sess->params->x_size;
make_show_field_maps.c:        y_size = sess->params->y_size;
make_show_field_maps.c:        area = sess->params->area;
make_show_field_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_show_field_maps.c:	am = sess->apparatus->map[0];
make_show_field_maps.c:		cp = sess->cells[i];
make_show_rate_maps.c:        area = sess->params->area;
make_show_rate_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_show_rate_maps.c:	if (sess->opts->read_breakpoints)
make_show_rate_maps.c:		cp = sess->cells[i];
make_show_rate_maps.c:		if (!sess->opts->read_breakpoints) {
make_show_rate_maps.c:	if (sess->opts->write_breakpoints)
make_show_smoothed_rate_maps.c:        area = sess->params->area;
make_show_smoothed_rate_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_show_smoothed_rate_maps.c:		cp = sess->cells[i];
make_show_speed_map.c:        area = sess->params->area;
make_show_speed_map.c:	sp = sess->speed;
make_show_time_map.c:        area = sess->params->area;
make_show_time_map.c:	tp = sess->time;
make_smoothed_rate_maps.c:        x_size = sess->params->x_size - 1;
make_smoothed_rate_maps.c:        y_size = sess->params->y_size - 1;
make_smoothed_rate_maps.c:        sf = sess->params->smoothing_factor;
make_smoothed_rate_maps.c:	n_units = sess->num_cells + sess->num_probes;
make_smoothed_rate_maps.c:	tm = sess->time->map;
make_smoothed_rate_maps.c:	am = sess->apparatus->map;
make_smoothed_rate_maps.c:		cp = sess->cells[i];
make_speed_map.c:        area = sess->params->area;
make_speed_map.c:        x_size = sess->params->x_size;
make_speed_map.c:        y_size = sess->params->y_size;
make_speed_map.c:	n_recs = sess->num_recs;
make_speed_map.c:	recs = sess->recs;
make_speed_map.c:	sm = sess->speed->map;
make_speed_map.c:	am = sess->apparatus->map;
make_speed_map.c:	sess->speed->average = sum / (sf8) sum_cnt;
make_speed_map.c:	sess->speed->max = max;
make_speed_map.c:	sess->speed->min = min;
make_speed_map.c:	thresh = (sf4) sess->params->global_speed_thresh;
make_spike_maps.c:	n_recs = sess->num_recs;
make_spike_maps.c:	c_map = sess->cell_map;
make_spike_maps.c:	p_map = sess->probe_map;
make_spike_maps.c:	rec = sess->recs;
make_spike_maps.c:				sm = sess->probes[p_num]->spike_map;
make_spike_maps.c:				sm = sess->cells[c_num]->spike_map;
make_temporal_subdivisions.c:	minutes = (si4) ((sess->time->total_secs / 60.0) + 0.5);
make_temporal_subdivisions.c:	sess->params->time_bins = n_time_bins = (si4) ceil((sf8) minutes / sess->params->time_division_duration);
make_temporal_subdivisions.c:	n_units = sess->num_cells + sess->num_probes;
make_temporal_subdivisions.c:	sess->temporal_subdivisions = (SESSION **) gmem((size_t) n_time_bins, sizeof(SESSION *));
make_temporal_subdivisions.c:		sess->temporal_subdivisions[i] = (SESSION *) gmem((size_t) 1, sizeof(SESSION));
make_temporal_subdivisions.c:		*(sess->temporal_subdivisions[i]) = *sess;
make_temporal_subdivisions.c:		dvsn = sess->temporal_subdivisions[i];
make_temporal_subdivisions.c:		dvsn->time->threshold = sess->time->threshold;
make_temporal_subdivisions.c:			dvsn->cells[j]->rate_thresh = sess->cells[j]->rate_thresh;
make_temporal_subdivisions.c:		dvsn->apparatus->map = sess->apparatus->map;
make_temporal_subdivisions.c:	n_recs = sess->num_recs;
make_temporal_subdivisions.c:	recs = sess->recs;
make_temporal_subdivisions.c:	n_bins = sess->params->time_bins;
make_temporal_subdivisions.c:	pos_recs_per_bin = (ui4) (sess->params->time_division_duration * 60.0 * sess->params->position_samp_freq);
make_temporal_subdivisions.c:		new_recs[i] = sess->temporal_subdivisions[i]->recs = (RECORD *) gmem((size_t) n_new_recs[i], sizeof(RECORD));
make_temporal_subdivisions.c:		sess->temporal_subdivisions[i]->num_recs = n_new_recs[i];
make_temporal_subdivisions.c:	*opts = *sess->opts;
make_temporal_subdivisions.c:	*dvsn->params = *sess->params;
make_temporal_subdivisions.c:	dvsn->params->read_bkpts_file = sess->params->write_bkpts_file;
make_time_map.c:        area = sess->params->area;
make_time_map.c:        x_size = sess->params->x_size;
make_time_map.c:        y_size = sess->params->y_size;
make_time_map.c:	n_recs = sess->num_recs;
make_time_map.c:	recs = sess->recs;
make_time_map.c:	tp = sess->time;
make_time_map.c:	if (sess->opts->no_pos_samp){
make_time_map.c:	pos_samp_freq = sess->params->position_samp_freq;
name_cells.c:	cm = sess->cell_map;
name_cells.c:	pm = sess->probe_map;
name_cells.c:	opts = sess->opts;
name_cells.c:			cp = sess->cells[cell_num];
name_cells.c:		cp = sess->probes[cell_num];
plot_building_functions.c:	num_bins = sess->params->plot_phase_bins;
plot_building_functions.c:	recs = sess->recs;
plot_building_functions.c:	n_recs = sess->num_recs;	
plot_building_functions.c:			plot->ys[0][i] = (sf4) (spks[i] / (tm[i] / (sf8) sess->params->position_samp_freq));
plot_building_functions.c:	num_bins = sess->params->plot_dir_bins;
plot_building_functions.c:	recs = sess->recs;
plot_building_functions.c:	n_recs = sess->num_recs;	
plot_building_functions.c:			plot->ys[0][i] = (sf4) (spks[i] / (tm[i] / (sf8) sess->params->position_samp_freq));
plot_building_functions.c:	num_bins = sess->params->interspike_int_bins;
plot_building_functions.c:	recs = sess->recs;
plot_building_functions.c:	n_recs = sess->num_recs;	
plot_building_functions.c:	temp = (sf8) sess->params->interspike_int_start_ms * ((sf8) TIME_STAMPS_PER_SECOND / 1000.0);
plot_building_functions.c:	temp = (sf8) sess->params->interspike_int_end_ms * ((sf8) TIME_STAMPS_PER_SECOND / 1000.0);
plot_building_functions.c:	plot->x_min = plot->xs[0][0] = sess->params->interspike_int_start_ms;
plot_building_functions.c:	plot->x_max = sess->params->interspike_int_end_ms;
plot_building_functions.c:	num_bins = sess->params->interspike_int_bins;
plot_building_functions.c:	recs = sess->recs;
plot_building_functions.c:	n_recs = sess->num_recs;	
plot_building_functions.c:	temp = (sf8) sess->params->autocorr_start_ms * ((sf8) TIME_STAMPS_PER_SECOND / 1000.0);
plot_building_functions.c:	temp = (sf8) sess->params->autocorr_end_ms * ((sf8) TIME_STAMPS_PER_SECOND / 1000.0);
plot_building_functions.c:	plot->x_min = plot->xs[0][0] = sess->params->autocorr_start_ms;
plot_building_functions.c:	plot->x_max = sess->params->autocorr_end_ms;
plot_building_functions.c:	recs = sess->recs;
plot_building_functions.c:	n_recs = sess->num_recs;	
plot_building_functions.c:	if (sess->opts->error_bars_on_waveforms)
plot_building_functions.c:	if (sess->opts->error_bars_on_waveforms) {
plot_building_functions.c:	if (sess->opts->error_bars_on_waveforms)
ps_print_cell_report.c:	n_pages = (sess->num_cells + 1) / CELLS_PER_PAGE;
ps_print_cell_report.c:	if ((sess->num_cells + 1) % CELLS_PER_PAGE)
ps_print_cell_report.c:	if (sess->opts->output_to_ps_files) {
ps_print_cell_report.c:		(void) sprintf(out_file, "%s/%s.ps", ps_dir, sess->name_str);
ps_print_cell_report.c:	app = sess->apparatus;
ps_print_cell_report.c:	opts = sess->opts;
ps_print_cell_report.c:	params = sess->params;
ps_print_cell_report.c:	time = sess->time;
ps_print_cell_report.c:	speed = sess->speed;
ps_print_cell_report.c:	new_page(sess->name_str, sess->anal_time, page, n_pages, fp);
ps_print_cell_report.c:	(void) fprintf(fp, "%f %f moveto\n(Data Format:  %s) show\n", x, y, sess->DataFormat);
ps_print_cell_report.c:	(void) fprintf(fp, "%f %f moveto\n(Session Date:  %s) show\n", x, y, sess->date_str);
ps_print_cell_report.c:	(void) fprintf(fp, "%f %f moveto\n(Session Time:  %s) show\n", x, y, sess->time_str);
ps_print_cell_report.c:	(void) fprintf(fp, "%f %f moveto\n(Session Description:  %s) show\n", x, y, sess->desc_str);
ps_print_cell_report.c:	(void) fprintf(fp, "%f %f moveto\n(Cells Analyzed:  %d) show\n", x, y, sess->num_cells);
ps_print_cell_report.c:		(void) fprintf(fp, "%f %f moveto\n(Probes Analyzed:  %d) show\n", x, y, sess->num_probes);
ps_print_cell_report.c:		(void) fprintf(fp, "%f %f moveto\n(Position Sampling Frequency \\(Hz\\):  %0.1f) show\n", x, y, sess->params->position_samp_freq);
ps_print_cell_report.c:	for (i = 0; i < sess->num_cells; ++i) {
ps_print_cell_report.c:		cp = sess->cells[i];
ps_print_cell_report.c:			if (i != sess->num_cells - 1) {
ps_print_cell_report.c:				new_page(sess->name_str, sess->anal_time, page, n_pages, fp);
ps_print_cell_report.c:	if (sess->opts->output_to_printer) {
ps_print_maps.c:	if (sess->opts->color_maps)
ps_print_maps.c:	if (sess->opts->time_map)
ps_print_maps.c:	if (sess->opts->speed_map)
ps_print_maps.c:	if (sess->opts->rate_maps)
ps_print_maps.c:		n_maps += sess->num_cells + sess->num_probes;
ps_print_maps.c:	if (sess->opts->smoothed_rate_maps)
ps_print_maps.c:		n_maps += sess->num_cells + sess->num_probes;
ps_print_maps.c:	if (sess->opts->field_maps)
ps_print_maps.c:		n_maps += sess->num_cells;
ps_print_maps.c:	if (sess->opts->rot_dir_div_rate_maps)
ps_print_maps.c:		n_maps += 2 * sess->num_cells;
ps_print_maps.c:	if (sess->opts->time_map) {
ps_print_maps.c:		maps[n_maps] = sess->time->show_map;
ps_print_maps.c:		medians[n_maps] = sess->time->medns;
ps_print_maps.c:		n_medians[n_maps] = sess->time->num_bkpts;
ps_print_maps.c:	if (sess->opts->speed_map) {
ps_print_maps.c:		maps[n_maps] = sess->speed->show_map;
ps_print_maps.c:		medians[n_maps] = sess->speed->medns;
ps_print_maps.c:		n_medians[n_maps] = sess->speed->num_bkpts;
ps_print_maps.c:		probe_num = sess->probe_map[i];
ps_print_maps.c:			if (sess->opts->rate_maps) {
ps_print_maps.c:				maps[n_maps] = sess->probes[probe_num]->show_rate_map;
ps_print_maps.c:				map_names[n_maps] = sess->probes[probe_num]->name_str;
ps_print_maps.c:				medians[n_maps] = sess->probes[probe_num]->rate_medns;
ps_print_maps.c:				n_medians[n_maps] = sess->probes[probe_num]->num_rate_bkpts;
ps_print_maps.c:			if (sess->opts->smoothed_rate_maps) {
ps_print_maps.c:				maps[n_maps] = sess->probes[probe_num]->show_smoothed_rate_map;
ps_print_maps.c:				map_names[n_maps] = sess->probes[probe_num]->name_str;
ps_print_maps.c:				medians[n_maps] = sess->probes[probe_num]->smoothed_rate_medns;
ps_print_maps.c:				n_medians[n_maps] = sess->probes[probe_num]->num_smoothed_rate_bkpts;
ps_print_maps.c:			cell_num = sess->cell_map[i][j];
ps_print_maps.c:				if (sess->opts->rate_maps) {
ps_print_maps.c:					maps[n_maps] = sess->cells[cell_num]->show_rate_map;
ps_print_maps.c:					map_names[n_maps] = sess->cells[cell_num]->name_str;
ps_print_maps.c:					medians[n_maps] = sess->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:				if (sess->opts->smoothed_rate_maps) {
ps_print_maps.c:					maps[n_maps] = sess->cells[cell_num]->show_smoothed_rate_map;
ps_print_maps.c:					map_names[n_maps] = sess->cells[cell_num]->name_str;
ps_print_maps.c:					medians[n_maps] = sess->cells[cell_num]->smoothed_rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->cells[cell_num]->num_smoothed_rate_bkpts;
ps_print_maps.c:				if (sess->opts->field_maps) {
ps_print_maps.c:					maps[n_maps] = sess->cells[cell_num]->show_field_map;
ps_print_maps.c:					map_names[n_maps] = sess->cells[cell_num]->name_str;
ps_print_maps.c:				if (sess->opts->rot_dir_div_rate_maps) {
ps_print_maps.c:					maps[n_maps] = sess->rotational_dir_subdivisions[CLOCKWISE]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					map_names[n_maps] = sess->rotational_dir_subdivisions[CLOCKWISE]->cells[cell_num]->name_str;
ps_print_maps.c:					medians[n_maps] = sess->rotational_dir_subdivisions[CLOCKWISE]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->rotational_dir_subdivisions[CLOCKWISE]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:					maps[n_maps] = sess->rotational_dir_subdivisions[COUNTERCLOCKWISE]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					map_names[n_maps] = sess->rotational_dir_subdivisions[COUNTERCLOCKWISE]->cells[cell_num]->name_str;
ps_print_maps.c:					medians[n_maps] = sess->rotational_dir_subdivisions[COUNTERCLOCKWISE]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->rotational_dir_subdivisions[COUNTERCLOCKWISE]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:	if (sess->opts->field_maps) {
ps_print_maps.c:	if (sess->opts->output_to_ps_files) {
ps_print_maps.c:		(void) sprintf(out_file, "%s/%s.ps", ps_dir, sess->name_str);
ps_print_maps.c:	map_pix_sz = sess->params->map_pixel_size;
ps_print_maps.c:	app = sess->apparatus;
ps_print_maps.c:	x_sz = sess->params->x_size;
ps_print_maps.c:	y_sz = sess->params->y_size;
ps_print_maps.c:			new_page(sess->name_str, sess->anal_time, page, n_pages, page_label, fp);
ps_print_maps.c:	if (sess->opts->output_to_printer) {
ps_print_maps.c:		if (sess->opts->color_maps)
ps_print_maps.c:	if (sess->opts->color_maps)
ps_print_maps.c:	dir_bins = sess->params->map_dir_bins;
ps_print_maps.c:	n_maps = sess->num_cells * (dir_bins + 1);
ps_print_maps.c:			cell_num = sess->cell_map[i][j];
ps_print_maps.c:					maps[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					medians[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:				maps[n_maps] = sess->cells[cell_num]->show_rate_map;
ps_print_maps.c:				map_types[n_maps] = sess->cells[cell_num]->name_str; /* not actually a type for this one */
ps_print_maps.c:				medians[n_maps] = sess->cells[cell_num]->rate_medns;
ps_print_maps.c:				n_medians[n_maps] = sess->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:					maps[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					medians[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->directional_subdivisions[mapmap[k]]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:	map_pix_sz = sess->params->map_pixel_size;
ps_print_maps.c:	if (sess->opts->output_to_ps_files) {
ps_print_maps.c:		(void) sprintf(out_file, "%s/%s.direc.ps", ps_dir, sess->name_str);
ps_print_maps.c:	app = sess->apparatus;
ps_print_maps.c:	x_sz = sess->params->x_size;
ps_print_maps.c:	y_sz = sess->params->y_size;
ps_print_maps.c:			new_page(sess->name_str, sess->anal_time, page, n_pages, page_label, fp);
ps_print_maps.c:	if (sess->opts->output_to_printer) {
ps_print_maps.c:		if (sess->opts->color_maps)
ps_print_maps.c:	if (sess->opts->color_maps)
ps_print_maps.c:	ph_bins = sess->params->map_phase_bins;
ps_print_maps.c:	n_maps = sess->num_cells * (ph_bins + 1);
ps_print_maps.c:			cell_num = sess->cell_map[i][j];
ps_print_maps.c:					maps[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					medians[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:				maps[n_maps] = sess->cells[cell_num]->show_rate_map;
ps_print_maps.c:				map_types[n_maps] = sess->cells[cell_num]->name_str; /* not actually a type for this one */
ps_print_maps.c:				medians[n_maps] = sess->cells[cell_num]->rate_medns;
ps_print_maps.c:				n_medians[n_maps] = sess->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:					maps[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					medians[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->phase_subdivisions[mapmap[k]]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:	map_pix_sz = sess->params->map_pixel_size;
ps_print_maps.c:	if (sess->opts->output_to_ps_files) {
ps_print_maps.c:		(void) sprintf(out_file, "%s/%s.phase.ps", ps_dir, sess->name_str);
ps_print_maps.c:	app = sess->apparatus;
ps_print_maps.c:	x_sz = sess->params->x_size;
ps_print_maps.c:	y_sz = sess->params->y_size;
ps_print_maps.c:			new_page(sess->name_str, sess->anal_time, page, n_pages, page_label, fp);
ps_print_maps.c:	if (sess->opts->output_to_printer) {
ps_print_maps.c:		if (sess->opts->color_maps)
ps_print_maps.c:	if (sess->opts->color_maps)
ps_print_maps.c:	time_bins = sess->params->time_bins;
ps_print_maps.c:	n_maps = sess->num_cells * (time_bins + 1);
ps_print_maps.c:	total_mins = (sf4) (sess->time->total_secs / 60.0);
ps_print_maps.c:		start_min = i * sess->params->time_division_duration;
ps_print_maps.c:		end_min = (i + 1) * sess->params->time_division_duration;
ps_print_maps.c:			cell_num = sess->cell_map[i][j];
ps_print_maps.c:					maps[n_maps] = sess->temporal_subdivisions[k]->cells[cell_num]->show_rate_map;
ps_print_maps.c:					map_names[n_maps] = sess->cells[cell_num]->name_str;
ps_print_maps.c:					medians[n_maps] = sess->temporal_subdivisions[k]->cells[cell_num]->rate_medns;
ps_print_maps.c:					n_medians[n_maps] = sess->temporal_subdivisions[k]->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:				maps[n_maps] = sess->cells[cell_num]->show_rate_map;
ps_print_maps.c:				map_names[n_maps] = sess->cells[cell_num]->name_str;
ps_print_maps.c:				medians[n_maps] = sess->cells[cell_num]->rate_medns;
ps_print_maps.c:				n_medians[n_maps] = sess->cells[cell_num]->num_rate_bkpts;
ps_print_maps.c:	map_pix_sz = sess->params->map_pixel_size;
ps_print_maps.c:	if (sess->opts->output_to_ps_files) {
ps_print_maps.c:		(void) sprintf(out_file, "%s/%s.time_div.ps", ps_dir, sess->name_str);
ps_print_maps.c:	app = sess->apparatus;
ps_print_maps.c:	x_sz = sess->params->x_size;
ps_print_maps.c:	y_sz = sess->params->y_size;
ps_print_maps.c:			new_page(sess->name_str, sess->anal_time, page, n_pages, page_label, fp);
ps_print_maps.c:	if (sess->opts->output_to_printer) {
ps_print_maps.c:		if (sess->opts->color_maps)
ps_print_plots.c:	if (sess->opts->phase_plots)
ps_print_plots.c:		n_plots += sess->num_cells;
ps_print_plots.c:	if (sess->opts->interspike_int_plots)
ps_print_plots.c:		n_plots += sess->num_cells;
ps_print_plots.c:	if (sess->opts->mean_waveform_plots)
ps_print_plots.c:		n_plots += sess->num_cells;
ps_print_plots.c:	if (sess->opts->dir_plots)
ps_print_plots.c:		n_plots += sess->num_cells;
ps_print_plots.c:	if (sess->opts->autocorr_plots)
ps_print_plots.c:		n_plots += sess->num_cells;
ps_print_plots.c:		probe_num = sess->probe_map[i];
ps_print_plots.c:			cell_num = sess->cell_map[i][j];
ps_print_plots.c:				if (sess->opts->phase_plots) {
ps_print_plots.c:					theta_phase_plot(plots + n_plots, sess->cells[cell_num], sess);
ps_print_plots.c:				if (sess->opts->interspike_int_plots) {
ps_print_plots.c:					interspike_int_plot(plots + n_plots, sess->cells[cell_num], sess);
ps_print_plots.c:				if (sess->opts->mean_waveform_plots) {
ps_print_plots.c:					mean_waveform_plot(plots + n_plots, sess->cells[cell_num], sess);
ps_print_plots.c:				if (sess->opts->dir_plots) {
ps_print_plots.c:					head_direction_plot(plots + n_plots, sess->cells[cell_num], sess);
ps_print_plots.c:				if (sess->opts->autocorr_plots) {
ps_print_plots.c:					autocorrelation_plot(plots + n_plots, sess->cells[cell_num], sess);
ps_print_plots.c:	if (sess->opts->output_to_ps_files) {
ps_print_plots.c:		(void) sprintf(out_file, "%s/%s.ps", ps_dir, sess->name_str);
ps_print_plots.c:			new_page(sess->name_str, sess->anal_time, page, n_pages, fp);
ps_print_plots.c:	if (sess->opts->output_to_printer) {
rate_thresh_dialog.c:	n_units = sess->num_cells + sess->num_probes;
rate_thresh_dialog.c:			cp = sess->cells[i];
rate_thresh_dialog.c:		sess->cells[cell_num]->rate_thresh = thresh;
rate_thresh_dialog.c:		cp = sess->cells[i];
read_write_app_map.c:	(void) sprintf(app_map_path, "%s/%s", app_map_dir, sess->params->read_app_map_file);
read_write_app_map.c:	area = sess->params->area;
read_write_app_map.c:	am = sess->apparatus->map[0];
read_write_app_map.c:	(void) sprintf(app_map_path, "%s/%s", app_map_dir, sess->params->write_app_map_file);
read_write_app_map.c:	x_size = sess->params->x_size;
read_write_app_map.c:	y_size = sess->params->y_size;
read_write_app_map.c:	am = sess->apparatus->map;
read_write_app_map.c:	(void) fprintf(stderr, "%c\n\tThe apparatus specified in the file \"%s\" is not of the correct dimensions for the current analysis. Terminating program.\n\n", 7, sess->params->read_app_map_file);
read_write_app_map.c:	(void) fprintf(stderr, "%c\n\tThe apparatus specified in the file \"%s\" contains incorrect entries. Terminating program.\n\n", 7, sess->params->read_app_map_file);
read_write_bkpts.c:	(void) sprintf(bkpt_path, "%s/%s", bkpt_dir, sess->params->read_bkpts_file);
read_write_bkpts.c:	for (i = 0; i < sess->num_cells; ++i) {
read_write_bkpts.c:		cp = sess->cells[i];
read_write_bkpts.c:	for (i = 0; i < sess->num_probes; ++i) {
read_write_bkpts.c:		cp = sess->probes[i];
read_write_bkpts.c:	(void) sprintf(bkpt_path, "%s/%s", bkpt_dir, sess->params->write_bkpts_file);
read_write_bkpts.c:	for (i = 0; i < sess->num_cells; ++i) {
read_write_bkpts.c:		cp = sess->cells[i];
read_write_bkpts.c:	for (i = 0; i < sess->num_probes; ++i) {
read_write_bkpts.c:		cp = sess->probes[i];
read_write_bkpts.c:	(void) fprintf(stderr, "%c\n\tThe breakpoints listed in the file \"%s\" do not match those necessary for the current data file (\"%s\"). Terminating program.\n\n", 7, sess->params->read_bkpts_file, sess->name_str);
set_opts_and_params.c:	opts = sess->opts;
set_opts_and_params.c:	params = sess->params;
set_opts_and_params.c:	(void) strcpy(sess->name_str, argv[index]);
set_opts_and_params.c:		strcpy(sess->DataFormat,"KM file");
set_opts_and_params.c:		strcpy(sess->DataFormat,"TS file");
set_opts_and_params.c:		strcpy(sess->DataFormat,"BPF file");
set_opts_and_params.c:		strcpy(sess->DataFormat,"UFF file");
set_opts_and_params.c:		strcat(sess->DataFormat," (No position sampling)");
set_opts_and_params.c:	opts = sess->opts = (OPTIONS *) gmem((size_t) 1, sizeof(OPTIONS));
set_opts_and_params.c:	params = sess->params = (PARAMETERS *) gmem((size_t) 1, sizeof(PARAMETERS));
set_opts_and_params.c:	opts = sess->opts;
set_opts_and_params.c:	params = sess->params;
set_opts_and_params.c:	directives = sess->directives = (DIRECTIVES *) gmem((size_t) 1, sizeof(DIRECTIVES));
set_opts_and_params.c:	opts = sess->opts;
set_opts_and_params.c:	directives = sess->directives;
set_opts_and_params.c:	opts = sess->opts;
set_opts_and_params.c:	directives = sess->directives;
set_state.c:	theta_cutoff = (ui1) sess->params->min_theta_score;
set_state.c:	maybe_cutoff = (ui1) sess->params->max_non_theta_score;;
set_thresholds.c:	n_units = sess->num_cells + sess->num_probes;
set_thresholds.c:	sess->time->threshold = sess->params->global_time_thresh;
set_thresholds.c:	if (sess->directives->calc_speed)
set_thresholds.c:		sess->speed->threshold = sess->params->global_speed_thresh;
set_thresholds.c:		sess->cells[i]->rate_thresh = sess->params->global_rate_thresh;
set_thresholds.c:		sess->cells[i]->smoothed_rate_thresh = sess->params->global_smoothed_rate_thresh;
set_thresholds.c:	if (sess->opts->change_rate_thresh)
set_thresholds.c:	if (sess->opts->change_smoothed_rate_thresh)
smoothed_rate_thresh_dialog.c:	n_units = sess->num_cells + sess->num_probes;
smoothed_rate_thresh_dialog.c:			cp = sess->cells[i];
smoothed_rate_thresh_dialog.c:		sess->cells[cell_num]->smoothed_rate_thresh = thresh;
smoothed_rate_thresh_dialog.c:		cp = sess->cells[i];
uff_to_km.c:	n_files = sess->num_cells / 4;
uff_to_km.c:	if (sess->num_cells % 4)
uff_to_km.c:	c1 = sess->name_str;
uff_to_km.c:	n_recs = sess->num_recs;
uff_to_km.c:	recs = sess->recs;
uff_to_km.c:	cell_map = sess->cell_map;
write_waveforms.c:        n_recs = sess->num_recs;
write_waveforms.c:        recs = sess->recs;
write_waveforms.c:        cm = sess->cell_map;
write_waveforms.c:        n_cells = sess->num_cells;
write_waveforms.c:	num_probes = sess->num_probes;
write_waveforms.c:	(void) sprintf(spk_file, "%s%s", get_env_var("WAVES_DIR"), sess->name_str);
write_waveforms.c:                	if (sess->cell_map[i][j] == NOT_CUT)
